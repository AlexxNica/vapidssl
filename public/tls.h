// Copyright 2016 The Fuchsia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef VAPIDSSL_PUBLIC_TLS_H
#define VAPIDSSL_PUBLIC_TLS_H
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#include <stddef.h>
#include <stdint.h>

#include "public/error.h"

// This is the public TLS connection API for VapidSSL.  It exposes a TLS
// connection type which represent an individual connection to a servers.
// VapidSSL promises not to dynamically allocate any memory, so the API has
// routines to get the size of opaque structures, and API calls that need memory
// take it as a parameter.

// TLS_CONFIG is a TLS configuration structure, defined in internal/config.h.
typedef struct tls_config_st TLS_CONFIG;

// TLS is a TLS connection, defined in internal/tls.h.
typedef struct tls_st TLS;

// tls_connection_id_t is a platform-specific handle to a particular connection
// managed at the transport layer.  Examples include socket file descriptors and
// QUIC-style connection numbers.  It is anticipated that on some platforms that
// transport details may change repeatedly over the lifetime of a connection
// (e.g. source IP address changes), but that the connection ID will be
// persistent.
typedef uint64_t tls_connection_id_t;

// TLS_size sets |out| to be the amount of memory needed for a call to
// |TLS_init|, given the values currently configured in |config|.
size_t TLS_size(const TLS_CONFIG *config);

// TLS_connect_size sets |out| to be the amount of memory needed for a call to
// |TLS_connect|, given the values currently in |config| and the UTF8-encoded
// server name.
size_t TLS_connect_size(const TLS_CONFIG *config);

// TLS_init takes a region of memory of |len| bytes starting at |mem| and
// configures a TLS connection structure according to the parameters set in
// |config| and associated with the platform-specific |connection_id|.
// |TLS_CONFIG_freeze| must already have been called on |config|. |TLS_init|
// returns NULL on error.
//
// |TLS_init| is thread-safe when compiled with support for threads; multiple
// threads may create TLS connections using the same |config| concurrently.
tls_result_t TLS_init(const TLS_CONFIG *config, void *mem, size_t len,
                      tls_connection_id_t cid, const char *server, TLS **out);

// TLS_connect performs a TLS 1.2 handshake using the given |tls| structure. It
// uses |len| additional bytes of memory starting at |mem| to perform the
// handshake. The UTF-8 encoded |server| name is used in 2 ways:
// - To create a IDN per https://tools.ietf.org/html/rfc5890 for use in the
//   Server Name Indication TLS extension, as described in
//   https://tools.ietf.org/html/rfc6066#section-3.
// - To match against the X520CommonName component of the Subject field of the
//   leaf X.509v3 certificate presented by the server, as described in
//   https://tools.ietf.org/html/rfc5280#section-4.1.2.6
// This functions returns
// |kTlsSuccess| if |tls| is connected and ready for calls to |TLS_read| and
// |TLS_write|, and |kTlsFailure| otherwise.
//
// Errors generated by |TLS_connect| include those from the platform-specific
// |io_read| and |io_write|.  In particular, this means that |TLS_connect| may
// fail with I/O errors when the connection is non-blocking,  In this case the
// caller may repeat the call to |TLS_connect| with the same |tls|, |mem|, and
// |len|.  It is an error to change |mem| or |len| between retries, or to call
// |TLS_connect| on an already connected |tls|.
//
// |TLS_connect| is thread-safe but does not block; if |TLS_connect| is called
// concurrently with any TLS API with the same |tls|, it will generate a
// |kTlsErrInvalidState| error and return |KFailure| immediately.
tls_result_t TLS_connect(TLS *tls, void *mem, size_t len);

// TLS_read receives up to |num| bytes via the |tls| structure, puts them in
// |buf|, and puts the number of bytes read in |out|. It returns |kTlsFailure|
// on error and |kTlsSuccess| otherwise.
//
// Errors generated by |TLS_connect| include those from the platform-specific
// |io_read|, TLS alerts sent from the peer, and |kTlsErrInvalidState| if not
// between calls to |TLS_connect| and |TLS_shutdown| or if a fatal alert has
// already been received.
//
// |TLS_read| is thread-safe when compiled with support for threads.  It will
// block if called concurrently with |TLS_connect|, |TLS_read| or |TLS_shutdown|
// using the same |tls|.  It will not block if called concurrently with
// |TLS_write|.  It is possible to have separate reader and writer threads that
// do not block each other.
tls_result_t TLS_read(TLS *tls, void *out, size_t *out_len, size_t num);

// TLS_write takes |num| bytes from |buf| and sends them via the |tls|
// structure.  It returns |kTlsFailure| on error and |kTlsSuccess| otherwise.
//
// Errors generated by |TLS_write| include those from the platform-specific
// |io_write| and |kTlsErrInvalidState| if not between calls to |TLS_connect|
// and |TLS_shutdown| or if a fatal alert has already been sent.
//
// Like BoringSSL, |TLS_write| commits to data passed it.  If a write fails
// because the connection is non-blocking, the call to |TLS_write| must be
// retried with the original write buffer (or a larger one containing the
// original as a prefix). Retries will fail if they do not reuse the same |buf|
// pointer.
//
// |TLS_write| is thread-safe when compiled with support for threads.  It will
// block if called concurrently with |TLS_connect|, |TLS_write| or
// |TLS_shutdown| using the same |tls|.  It will not block if called
// concurrently with |TLS_read|.  It is possible to have separate reader and
// writer threads that do not block each other.
tls_result_t TLS_write(TLS *tls, const void *buf, size_t num);

// TLS_shutdown sends a CloseNotify alert as necessary to the remote peer to
// indicate that the |tls| connection is being torn down.  If a CloseNotify
// alert has not already been received, it attempts to read the same alert from
// the remote peer.  This call returns |kTlsSuccess| if the alerts have been
// exchanged, and |kTlsFailure| otherwise.
//
// Errors generated by |TLS_shutdown| include those from the platform-specific
// |io_read| and |io_write| and |kTlsErrInvalidState| if |TLS_shutdown| is
// called twice without calling |TLS_connect|.
//
// |TLS_shutdown| is thread-safe when compiled with support for threads.  It
// will block if called concurrently with any TLS APIs with the same |tls|.
//
// API consumers MUST call |TLS_shutdown| when ending a TLS connection.  Failure
// to do so may lead to a truncation attack.
tls_result_t TLS_shutdown(TLS *tls);

// TLS_cleanup zeros the memory used by the |tls| connection and returns it. If
// |tls| is NULL, it returns NULL.  It will generate an error if |tls| has been
// connected via |TLS_connect| but not shut down via |TLS_shutdown|.
//
// |TLS_cleanup| is thread-safe when compiled with support for threads.
void *TLS_cleanup(TLS *tls);

#ifdef __cplusplus
}
#endif  // __cplusplus
#endif  // VAPIDSSL_PUBLIC_TLS_H
