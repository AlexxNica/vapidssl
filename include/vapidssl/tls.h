/* Copyright (c) 2016, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#ifndef VAPIDSSL_TLS_H_
#define VAPIDSSL_TLS_H_
#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

#include <stddef.h>
#include <stdint.h>

#include "vapidssl/error.h"


/* This is the public TLS connection API for VapidSSL.  It exposes a TLS
 * connection type which represent an individual connection to a servers.
 * VapidSSL promises not to dynamically allocate any memory, so the API has
 * routines to get the size of opaque structures, and API calls that need memory
 * take it as a parameter. */

/* TLS_CONFIG is a TLS configuration structure, defined in internal/config.h. */
typedef struct tls_config_st TLS_CONFIG;

/* TLS is a TLS connection, defined in internal/tls.h. */
typedef struct tls_st TLS;

/* tls_connection_id_t is a platform-specific handle to a particular connection
 * managed at the transport layer.  Examples include socket file descriptors and
 * QUIC-style connection numbers.  It is anticipated that on some platforms that
 * transport details may change repeatedly over the lifetime of a connection
 * (e.g. source IP address changes), but that the connection ID will be
 * persistent. */
typedef uint64_t tls_connection_id_t;

/* TLS_size sets |out| to be the amount of memory needed for a call to
 * |TLS_new|, given the values currently configured in |config|. */
tls_result_t TLS_size(const TLS_CONFIG *config, size_t *out);

/* TLS_connect_size sets |out| to be the amount of memory needed for a call to
 * |TLS_connect|, given the values currently in |config| and the UTF8-encoded
 * server name. */
tls_result_t TLS_connect_size(const TLS_CONFIG *config, size_t *out,
                              const char *server);

/* TLS_new takes a region of memory of |len| bytes starting at |mem| and
 * configures a TLS connection structure according to the parameters set in
 * |config| and associated with the platform-specific |connection_id|.
 * |TLS_CONFIG_freeze| must already have been called on |config|. |TLS_new|
 * returns NULL on error.
 *
 * |TLS_new| is thread-safe when compiled with support for threads; multiple
 * threads may create TLS connections using the same |config| concurrently. */
TLS *TLS_new(const TLS_CONFIG *config, tls_connection_id_t connection_id,
             void *mem, size_t len);

/* TLS_connect performs a TLS 1.2 handshake using the given |tls| structure. It
 * uses |len| additional bytes of memory starting at |mem| to perform the
 * handshake. The UTF-8 encoded |server| name is used in 2 ways:
 *  - To create a IDN per https://tools.ietf.org/html/rfc5890 for use in the
 *    Server Name Indication TLS extension, as described in
 *    https://tools.ietf.org/html/rfc6066#section-3.
 *  - To match against the X520CommonName component of the Subject field of the
 *    leaf X.509v3 certificate presented by the server, as described in
 *    https://tools.ietf.org/html/rfc5280#section-4.1.2.6
 * This functions returns |kTlsSuccess| if |tls| is connected and ready for
 * calls to |TLS_read| and |TLS_write|, and |kTlsFailure| otherwise.
 *
 * Errors generated by |TLS_connect| include those from the platform-specific
 * |io_read| and |io_write|.  In particular, this means that |TLS_connect| may
 * fail with I/O errors when the connection is non-blocking,  In this case the
 * caller may repeat the call to |TLS_connect| with the same |tls|, |mem|, and
 * |len|.  It is an error to change |mem| or |len| between retries, or to call
 * |TLS_connect| on an already connected |tls|.
 *
 * |TLS_connect| is thread-safe but does not block; if |TLS_connect| is called
 * concurrently with any TLS API with the same |tls|, it will generate a
 * |kTlsErrInvalidState| error and return |KFailure| immediately. */
tls_result_t TLS_connect(TLS *tls, const char *server, void *mem, size_t len);

/* TLS_read receives up to |num| bytes via the |tls| structure, puts them in
 * |buf|, and puts the number of bytes read in |out|. It returns |kTlsFailure|
 * on error and |kTlsSuccess| otherwise.
 *
 * Errors generated by |TLS_connect| include those from the platform-specific
 * |io_read|, TLS alerts sent from the peer, and |kTlsErrInvalidState| if not
 * between calls to |TLS_connect| and |TLS_shutdown| or if a fatal alert has
 * already been received.
 *
 * |TLS_read| is thread-safe when compiled with support for threads.  It will
 * block if called concurrently with |TLS_connect|, |TLS_read| or
 * |TLS_shutdown| using the same |tls|.  It will not block if called
 * concurrently with |TLS_write|.  It is possible to have separate reader
 * and writer threads that do not block each other. */
tls_result_t TLS_read(TLS *tls, void *out, size_t *out_len, size_t num);

/* TLS_write takes |num| bytes from |buf| and sends them via the |tls|
 * structure.  It returns |kTlsFailure| on error and |kTlsSuccess| otherwise.
 *
 * Errors generated by |TLS_write| include those from the platform-specific
 * |io_write| and |kTlsErrInvalidState| if not between calls to |TLS_connect|
 * and |TLS_shutdown| or if a fatal alert has already been sent.
 *
 * Like BoringSSL, |TLS_write| commits to data passed it.  If a write fails
 * because the connection is non-blocking, the call to |TLS_write| must be
 * retried with the original write buffer (or a larger one containing the
 * original as a prefix). Retries will fail if they do not reuse the same |buf|
 * pointer.
 *
 * |TLS_write| is thread-safe when compiled with support for threads.  It will
 * block if called concurrently with |TLS_connect|, |TLS_write| or
 * |TLS_shutdown| using the same |tls|.  It will not block if called
 * concurrently with |TLS_read|.  It is possible to have separate reader
 * and writer threads that do not block each other. */
tls_result_t TLS_write(TLS *tls, const void *buf, size_t num);

/* TLS_shutdown sends a CloseNotify alert as necessary to the remote peer to
 * indicate that the |tls| connection is being torn down.  If a CloseNotify
 * alert has not already been received, it attempts to read the same alert from
 * the remote peer.  This call returns |kTlsSuccess| if the alerts have been
 * exchanged, and |kTlsFailure| otherwise.
 *
 * Errors generated by |TLS_shutdown| include those from the platform-specific
 * |io_read| and |io_write| and |kTlsErrInvalidState| if |TLS_shutdown| is
 * called twice without calling |TLS_connect|.
 *
 * |TLS_shutdown| is thread-safe when compiled with support for threads.  It
 * will block if called concurrently with any TLS APIs with the same |tls|.
 *
 * API consumers MUST call |TLS_shutdown| when ending a TLS connection.  Failure
 * to do so may lead to a truncation attack. */
tls_result_t TLS_shutdown(TLS *tls);

/* TLS_cleanup zeros the memory used by the |tls| connection and returns it. If
 * |tls| is NULL, it returns NULL.  It will generate an error if |tls| has been
 * connected via |TLS_connect| but not shut down via |TLS_shutdown|.
 *
 * |TLS_cleanup| is thread-safe when compiled with support for threads. */
void *TLS_cleanup(TLS *tls);

#if defined(__cplusplus)
}
#endif /* __cplusplus */
#endif /* VAPIDSSL_TLS_H_ */
