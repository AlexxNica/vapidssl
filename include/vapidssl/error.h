/* Copyright (c) 2016, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#ifndef INCLUDE_VAPIDSSL_ERROR_H_
#define INCLUDE_VAPIDSSL_ERROR_H_

#include <stddef.h>
#include <stdint.h>

#if defined(__cplusplus)
extern "C" {
#endif

typedef int tls_error_t;

/* This is the public API for error handling in VapidSSL.  It has API calls to
 * get the most recent error and associated location information about where the
 * error occured.
 *
 * VapidSSL does not dynamically allocate any memory, so the API has routines to
 * get the size of opaque structures, and API calls that need memory take it as
 * an argument. */

/* Errors are represented as packed 32 bit signed integers as follows:
 *   Bits 30 to 24 indicate who reported the error.
 *   Bits 22 to 16 optionally indicate an error category.
 *   Bits 14 to 0 indicate a specific reason for the error.
 * Bits 31, 23, and 15 are zero, to avoid any signedness confusion when
 * interpreting the error or its components as char, shorts, or ints.  These
 * ranges and the values chosen below are designed to be as compatible as
 * possible with BoringSSL and C standard library error codes.
 *
 * |TLS_ERROR_source|, |TLS_ERROR_category|, and |TLS_ERROR_reason| take a
 * packed |error| and mask the relevant bits. */
#define TLS_ERROR_source(error) (0x7f000000 & (error))
#define TLS_ERROR_category(error) (0x007f0000 & (error))
#define TLS_ERROR_reason(error) (0x00007fff & (error))

/* tls_result_t is used to indicate whether or not a particular call executed
 * successfully. All routines follow these rules with regards to return values:
 *  - Simple getters that cannot fail return primitives, e.g. size_t.
 *  - Finders and factories return pointers or NULL on error.
 *  - Functions which may fail due to network or API inputs return |kTlsFailure|
 *    on error, |kTlsSuccess| otherwise.
 *  - All other functions return void.
 * Note that 0 for return values indicates failure and thus make return values
 * useful for conditional expressions and consistent with BoringSSL. Conversely,
 * 0 for error codes indicates success, as with errno. */
typedef enum tls_result_t {
  kTlsFailure = 0,
  kTlsSuccess = 1,
} tls_result_t;

/* error_source_t indicates where an error occurred.  |kTlsErrArch| is chosen to
 * be 0 so that platform errors may be handled normally. */
enum tls_error_source_t {
  /* Errors reported by the C standard library or underlying OS.  For these
     errors, the category is always 0 and the reason matches |errno|, so that
     the packed error matches the values defined in asm-generic/errno-base.h (or
     similar). */
  kTlsErrArch = 0x00000000,

  /* Errors reported by the crypto library.  The category and reason are library
     specific.  As an example, OpenSSL and BoringSSL packed errors are mapped by
     setting the category to the value of |TLS_ERROR_GET_LIB| and the reason to
     the value of |TLS_ERROR_GET_REASON| (the value of TLS_ERROR_GET_FUNC is
     ignored). */
  kTlsErrCrypt = 0x01000000,

  /* Errors received as TLS alerts from the remote peer. For these errors, the
     category is always 0 and the reason matches either a value of
     |error_alert_t| or of |error_peer_t|.*/
  kTlsErrPeer = 0x02000000,

  /* Errors from the VapidSSL library itself. For these errors, the category may
     be a value from |error_category_t| and the reason matches either a value of
     |error_alert_t| or of |error_vapid_t|.*/
  kTlsErrVapid = 0x03000000,
};

/* tls_error_category_t defines categories to help narrow down the most common
 * |tls_error_alert_t|s generated by the library. */
enum tls_error_category_t {
  /* |kTlsErrDecodeError| categories. */
  kTlsErrTLS1_2 = 0x010000,
  kTlsErrX509v3 = 0x020000,
  kTlsErrASN1_DER = 0x030000,

  /* |kTlsErrInternalError| categories. */
  kTlsErrOutOfMemory = 0x040000,
  kTlsErrIntegerOverflow = 0x050000,
};

/* tls_error_alert_t describes errors derived from the TLS alerts specified by
 * https://tools.ietf.org/html/rfc5246#section-7.2.  These error codes are used
 * both to send and receieve alerts as appropriate; use the error's source to
 * distinguish.
 *
 * These correspond to the SSL3_AD_* and TLS1_AD_* definitions in openssl/ssl.h
 * and openssl/tls1.h, respectively.  That is, kTlsErrCloseNotify has the same
 * value as SSL3_AD_CLOSE_NOTIFY, kTlsErrDecodeError has the same value as
 * TLS1_AD_DECODE_TLS_ERROR, etc. */
typedef enum tls_error_alert_t {
  /* Reporter received a CloseNotify. */
  kTlsErrCloseNotify = 0,
  /* Reporter received a message out of order or an unknown message. */
  kTlsErrUnexpectedMessage = 10,
  /* Reporter failed to decrypt and verify a record. */
  kTlsErrBadRecordMac = 20,
  /* Reporter received a message larger than its maximum fragment length. */
  kTlsErrRecordOverflow = 22,
  /* Reporter was unable to negotiate at least one security parameter with its
     peer. */
  kTlsErrHandshakeFailure = 40,
  /* Reporter failed to decode a certificate or verify its signature. */
  kTlsErrBadCertificate = 42,
  /* Reporter received a certificate with an unsupported type. */
  kTlsErrUnsupportedCertificate = 43,
  /* Reporter received a revoked certificate. */
  kTlsErrRevokedCertificate = 44,
  /* Reporter received a revoked certificate. */
  kTlsErrExpiredCertificate = 45,
  /* Reporter encountered an unspecified error while parsing a received
     certificate. */
  kTlsErrCertificateUnknown = 46,
  /* Reporter received an invalid parameter or one different than what was
     specifed earlier. */
  kTlsErrIllegalParameter = 47,
  /* Reporter received a certificate trust that does not include any
     certificates matching the trusted certificate digests. */
  kTlsErrUnknownCA = 48,
  /* Reporter could not decode a message, either due to a bad length or an
     unrecognized value for an enumerated field. */
  kTlsErrDecodeError = 50,
  /* Reporter failed to verify cryptographically sensitive data, namely either
     the signature on key exchange parameters or the Finished message. */
  kTlsErrDecryptError = 51,
  /* Reporter received an unsupported version. */
  kTlsErrProtocolVersion = 70,
  /* Server requires stronger ciphers than the library supports. */
  kTlsErrInsufficientSecurity = 71,
  /* Reporter ran out of memory or encountered some other internal error. */
  kTlsErrInternalError = 80,
  /* Server sent a HelloRequest, which the library doesn't support. */
  kTlsErrNoRenogiation = 100,
  /* Server sent a duplicate or unrequested extension. */
  kTlsErrUnsupportedExtension = 110,
};

/* tls_error_peer_t describes errors that are a result of data received from the
 * peer. The numbers are chosen so as not to collide with |error_alert_t|. */
enum tls_error_peer_t {
  /* The underlying socket was closed by the remote peer while reading. */
  kTlsErrConnectionClosed = 0x101,
  /* The remote peer has sent an excessive number of empty fragments.  There
     shouldn't be a strong need for empty fragments (no TLS 1.0 or CBC), and
     excessive empty fragments becomes a DoS risk. */
  kTlsErrTooManyEmptyFragments = 0x102,
  /* The remote peer sent an alert we didn't understand.  This is separate from
     |kTlsErrDecodeError| because we don't want to send an alert in response to
     a bad alert. */
  kTlsErrBadAlert = 0x103,
};

/* tls_error_vapid_t describes errors arising from VapidSSL library itself.  All
 * of these errors are the result of an application using the library's API
 * incorrectly (e.g. not providing sufficient memory). The numbers are chosen so
 * as not to collide with |error_alert_t|. */
enum tls_error_vapid_t {
  /* The error system wasn't initialized. */
  kTlsErrUninitialized = 0x201,
  /* The caller invoked an API call with null or incorrect arguments. */
  kTlsErrInvalidArgument = 0x202,
  /* The caller invoked an API call at an inappropriate time, i.e. calling
     TLS_read before TLS_connect. */
  kTlsErrInvalidState = 0x203,
  /* Although VapidSSL knows about an algorithm, it isn't available in the
     crypto library. */
  kTlsErrUnsupportedAlgorithm = 0x204,
  /* The library's configuration does not include an acceptable set of security
     parameters, e.g. all ciphers are disabled. */
  kTlsErrNoAvailableOptions = 0x205,
  /* A buffer passed to TLS_read or TLS_write doesn't match the one passed to a
     previous, incomplete call.  Should only occur when using non-blocking
     sockets. */
  kTlsErrBufferChanged = 0x206,
  /* An unimplemented code path was followed. Should not occur outside
     development! */
  kTlsErrNotImplemented = 0x207,
};

/* TLS_ERROR_size sets |out| to be the amount of memory needed for a call to
 * |TLS_ERROR_init| to create a thread-local error structure that can hold the
 * packed error code and location information. */
tls_result_t TLS_ERROR_size(size_t* out);

/* TLS_ERROR_init takes a memory region of |len| bytes starting at |mem| and
 * uses it to create a thread-local error structure for the packed error code
 * and location information. */
tls_result_t TLS_ERROR_init(void* mem, size_t len);

/* TLS_ERROR_get copies the location information to |out_file| and |out_line|,
 * if not NULL, and returns the packed error code from the thread local error
 * structure. If no thread-local storage was initialized using |TLS_ERROR_init|,
 * |TLS_ERROR_get| always returns |kTlsErrUninitialized|, regardless of any
 * actual errors encountered. */
int32_t TLS_ERROR_get(const char** out_file, int* out_line);

/* TLS_ERROR_cleanup clears the thread-local error structure and returns the
 * memory it was using for it.  Subsequent calls |TLS_ERROR_cleanup| do nothing
 * and return NULL. */
void* TLS_ERROR_cleanup(void);

#if defined(__cplusplus)
}
#endif

#endif /* INCLUDE_VAPIDSSL_ERROR_H_ */
